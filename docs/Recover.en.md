## Recover

#### Overview

The checkpoint recovery feature allows tasks to continue from the last interrupted point when execution fails. The recovery process involves restoring the main logic of the task along with the state of the `Context` and `Resource`, ensuring that the task remains consistent with its initial execution after recovery.

[See Context Documentation](./Context.en.md) |[See Resource Documentation](./Resource.en.md)

---

#### Enabling Checkpoint Recovery

By default, the checkpoint recovery feature is disabled. To enable this functionality, you need to call the `EnableRecover()` method on the `Flow` object or enable it through the default configuration.

```go
// Enable Recover in Flow
wf := flow.RegisterFlow("Recover")
wf.EnableRecover()

// Enable Recover in Default 
flow.DefaultConfig().EnableRecover()
```

Once enabled, when a task execution fails, the framework generates a snapshot of the current `Context` and `Resource`, saving it through serialization. Users are required to register non-basic types in the `Context` and `Resource` using `RegisterType`.

```go
// Register a custom type using generics
flow.RegisterType[YourStruct]()
```

---

#### Recovery Mechanism

- **Snapshot Generation**: When a recoverable task fails, the framework creates snapshots of the `Context` and `Resource`, serializing them using gob before calling a user-provided persistence interface for saving.

- **Task Recovery**: After a task fails, the framework suspends it and records the failure point. During recovery, it reloads the saved snapshot and continues execution from the failed `Step` or preceding `Callback` (checkpoint recovery). During recovery, subsequent callbacks are also re-executed (replay).

- **Idempotency Guarantee**: During recovery, `Steps` and subsequent callbacks may be executed multiple times, so they must ensure idempotency. To avoid repeated execution, you can call `Exclude(Recovering)` in subsequent callbacks to skip duplicate executions during recovery. It is recommended to always ensure idempotency in subsequent callbacks to maintain consistent behavior during task recovery.

---

#### Resource Recovery

Light-Flow manages internal suspension through persistent `Context`, while using resources to abstract external systems to meet checkpoint recovery needs.

During task execution and recovery, resource states are managed using the `Suspend` and `Recover` methods. For more information on resource management, refer to [Resource Documentation](./Resource.en.md).

---

#### Persistence and Sensitive Data Handling

The framework provides flexible persistence interfaces that allow users to customize how `Context` and `Resource` are saved and loaded, choosing appropriate databases or storage solutions.

**Example: Using GORM Plugin for Persistence**

The following example demonstrates how to implement custom persistence using the GORM plugin:

```go
import plugins "github.com/Bilibotter/light-flow-plugins/orm"

// Open a database connection
db, _ := gorm.Open(mysql.Open(dsn), &gorm.Config{})
// Inject the suspend plugin for persistence
err := plugins.NewSuspendPlugin(db).InjectSuspend()
```

------

For sensitive data, it is advisable to clear this data during `Suspend` and regenerate it during `Recover` to avoid storing sensitive information directly in the database. If sensitive data cannot be handled through resource management, you can use Light-Flow's encryption features.

**Example: Encrypting Sensitive Data**

Use `AES256` to encrypt keys like `pwd` and `password`, with `"secret"` as the key:

```go
// Set AES256 encryptor for sensitive keys
flow.SetEncryptor(flow.NewAES256Encryptor([]byte("secret"), "pwd", "password"))
```

---

#### Executing Recovery

There are two options for recovery:

1. Use a `FinishedFlow` generated by `DoneFlow`.
2. Use the `RecoverWorkFlow` method to recover a corresponding workflow by its FlowId.

**Example 1: Recovering Using FinishedWorkFlow**

```go
// Create a FinishedFlow instance and recover from it
ff := flow.DoneFlow("Recover", nil)
// Call Recover method to restore the workflow state
ff.Recover()
```

**Example 2: Recovering Using FlowId**

```go
// Restore the workflow using its FlowId
flow.RecoverFlow("xxxxxxxxxxx")
```

**Example 3: Simulating Step Failure and Then Recovering**

```go
import (
	"fmt"
	plugins "github.com/Bilibotter/light-flow-plugins/orm"
	"github.com/Bilibotter/light-flow/flow"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

type YourStruct struct {
	ID   int
	Name string
}

// Step1 function simulates a task step that may fail
func Step1(step flow.Step) (any, error) {
	fmt.Printf("[Step: %s] start\n", step.Name())
    // If recovering, simulate success; otherwise, simulate failure.
	if step.Has(flow.Recovering) {
		fmt.Printf("[Step: %s] success\n", step.Name())
		return nil, nil
	}
	step.Set("key", YourStruct{ID: 1, Name: "John"})
	fmt.Printf("[Step: %s] failed\n", step.Name())
	return nil, fmt.Errorf("something went wrong")
}

// Step2 function retrieves data set by Step1 and completes successfully.
func Step2(step flow.Step) (any, error) {
	fmt.Printf("[Step: %s] start\n", step.Name())
	value, _ := step.Get("key")
	fmt.Printf("[Step: %s] get value: %v\n", step.Name(), value)
	fmt.Printf("[Step: %s] success\n", step.Name())
	return nil, nil
}

func init() {
	dsn := "xxx"
	db, _ := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	plugins.NewSuspendPlugin(db).InjectSuspend()
    
	flow.RegisterType[YourStruct]()
    
	wf := flow.RegisterFlow("Recover")
	wf.EnableRecover()
    
	wf.Process("Recover").Follow(Step1, Step2)
}

func main() {
	ff := flow.DoneFlow("Recover", nil)
	fmt.Printf("======Recover======\n")
	ff.Recover()
}
```

---

#### Multiple Recovery Attempts

If task recovery fails, the framework will suspend the task again, waiting for another opportunity to recover. This mechanism ensures that tasks do not become permanently interrupted due to a single recovery failure.

It is important to note that only workflows that have failed can be recovered.