# Resource Management

#### Overview

The resource management feature of Light-Flow allows users to utilize external resources (such as database connections, API clients, etc.) within task `Steps`, ensuring that these resources are correctly initialized, suspended, recovered, and released during task execution. Resource management supports automated lifecycle control, ensuring that the state of resources can be properly saved and restored during task interruptions or recoveries.

> **Important Note**: Resources do not necessarily have to be physical entities; they can also represent abstract external systems. Any external system that requires specific recovery operations for checkpoint restoration can be treated as a resource and integrated into the workflow.

---

#### Resource Registration

Before using a resource, it must be registered with the resource manager. Once registered, resources can be attached to a `Process`, and the framework will manage them automatically.

- **Registering Resources**: Use the `AddResource` method to register a resource with the resource manager.

  **Example**:

  ```go
  flow.AddResource("Resource") // Register the resource
  ```

- **Attaching Resources**: Use the `Attach` method to attach a resource to a `Process`. You can pass `initParam` as input for the resource's `Initialize` method, and the return value will be used as the resource entity in subsequent operations.

  **Example**:

  ```go
  func Step(step flow.Step) (any, error) {
      res, err := step.Attach("resource", "initParam") // Attach the resource with initialization parameters
      if err != nil {
          return nil, err
      }
  }
  ```

---

#### Resource Lifecycle Management

The lifecycle of resources within a `Process` includes four key operations:

- **Initialize**: After attaching a resource, the framework automatically calls the `Initialize` method to ensure proper initialization before task execution.
- **Release**: Regardless of whether the task succeeds or fails, after the `Process` execution ends, the system will automatically call the `Release` method to free up resources and prevent leaks.
- **Suspend**: When a task is interrupted or a checkpoint is saved, the framework calls the `Suspend` method to save the current state of resources. This operation is typically used to clear sensitive data and save necessary information for recovery (such as user IDs or session IDs). Users do not need to manually persist this data; the framework handles it automatically.
- **Recover**: When resuming a task, the system uses information saved by `Suspend` through the `Recover` method to restore resource status, ensuring that resources are correctly loaded and can support task continuation. [See Recover Documentation](./Recover.en.md)

These operations are managed automatically by the framework without requiring manual calls from users.

**Example**:

```go
flow.AddResource("Resource").
    OnInitialize(InitializeMethod). // Set the initialization method
    OnSuspend(SuspendMethod).         // Set the suspend method
    OnRelease(ReleaseMethod).         // Set the release method
    OnRecover(RecoverMethod)          // Set the recovery method
```

---

#### Resource Usage

The parameters for `OnInitialize`, `OnSuspend`, `OnRelease`, and `OnRecover` methods are all `Resource` objects.

The `Resource` provides several main methods:

- **Put**: Write key-value pairs to the `Resource`.
- **Fetch**: Read key-value pairs from the `Resource`.
- **Entity**: Retrieve the resource entity generated by `OnInitialize`.
- **Update**: Update the resource entity.
- **Clear**: Clear both the resource entity and its key-value pairs.
- **Has**, **Success**: Used to determine the state of a `Process`.

**Example 1: Connection Without Checkpoint Recovery**

```go
type UnRecoverConnect struct {
	*gorm.DB
}

func (u *UnRecoverConnect) OnInitialize(res flow.Resource, _ any) (entity any, err error) {
	fmt.Printf("[Process: %s] initializing [Resource: %s]\n", res.ProcessName(), res.Name()) // Log initialization
	tx := u.DB.Begin() // Begin a new transaction
	return tx, nil
}

func (u *UnRecoverConnect) OnRelease(res flow.Resource) error {
	fmt.Printf("[Process: %s] releasing [Resource: %s]\n", res.ProcessName(), res.Name()) // Log resource release
	if res.Success() {
		return res.Entity().(*gorm.DB).Commit().Error // Commit if successful
	}
	return res.Entity().(*gorm.DB).Rollback().Error // Rollback if not successful
}
```

**Example 2: Connection With Checkpoint Recovery**

```go
type RecoverConnect struct {
	*gorm.DB
}

func (r *RecoverConnect) OnInitialize(res flow.Resource, initParam any) (any, error) {
	tx := r.Begin() // Begin a new transaction
	return tx, nil
}

func (r *RecoverConnect) OnRelease(res flow.Resource) error {
	// Since this resource can be recovered, there's no need to rollback on exception
	return r.Commit().Error // Commit changes
}
```

---

#### Timely Resource Management

Certain time-sensitive resources (like temporary tokens or sessions) may expire during task recovery. To ensure these resources remain valid upon recovery, users need to save information required for regenerating these resources in the `Suspend` method and use this information in the `Recover` method.

#### Clearing Sensitive Data

In the `Suspend` method, use the `Clear` method to remove sensitive data to ensure it is not persisted. Then, use the `Put` method to save critical information needed for recovery, such as user IDs or other credential data.

#### Regenerating Resources

In the `Recover` method, use the `Fetch` method to retrieve critical information saved during suspension. Based on this information, regenerate time-sensitive resources and call the `Update` method to inject new resources into the process for normal task recovery.

**Example**:

```go
func PasswordInit(res flow.Resource, initParam any) (any, error) {
	pwd := GetPassWordByUserID(initParam.(string)) // Fetch password based on user ID
	res.Put("userId", initParam.(string)) // Store user ID for recovery
	return pwd, nil
}

func PasswordSuspend(res flow.Resource) error {
	// Save userId; Clear will remove userId from resource
	userId, exist := res.Fetch("userId")
	if !exist {
		return fmt.Errorf("userId not exist") // Error if userId not found
	}
	res.Clear() // Clear sensitive data
	res.Put("userId", userId) // Preserve userId for recovery
	return nil
}

func PasswordRecover(res flow.Resource) error {
	userId, exist := res.Fetch("userId") // Retrieve userId
	if !exist {
		return fmt.Errorf("userId not exist") // Error if userId not found
	}
	pwd := GetPassWordByUserID(userId.(string)) // Fetch password again
	res.Update(pwd) // Update resource with new password
	return nil
}

func init() {
	flow.AddResource(PasswordR).
		OnInitialize(PasswordInit).
		OnSuspend(PasswordSuspend).
		OnRelease(PasswordRecover);
}
```

---

#### Order of Resource Checkpoint Recovery

When checkpoint recovery is enabled, resource recovery follows this order:

1. **Initialize Resource**: Initialize resources before task execution begins.
2. **Process Error**: An error or exception occurs during task execution.
3. **Suspend Resource**: Suspend current state and save necessary information.
4. **Release Resource**: Release all related resources after task failure.
5. **Recover Process**: Call `Recover` to restore task workflow.
6. **Recover Resources**: Restore resource status before tasks begin recovering from checkpoints.
7. **Continue Executing Tasks**: Continue executing tasks.
8. **Release All Resources**: Release all related resources after task completion.

The lifecycle flowchart for resources is as follows:

```mermaid
%%{init: {'theme': 'neutral', 'themeVariables': { 'primaryColor': '#333', 'lineColor': '#333', 'textColor': 'black' } } }%%
flowchart TD
    Z[Process Start] --> A[Initialize Resource]
    A --> B[Process End]
    B --> C{Need Recovery?}
    C -->|Yes| D[Suspend Resource]
    C -->|No| E[Release Resource]
    D --> F[Release Resource]
    F --> G[Wait to Recover]
    G --> Y[Recover Resource]
    Y --> H[Release Resource]

    %% Style Definitions %%
    linkStyle default stroke:#888888
    classDef startEnd fill:#00ff00,stroke:#000000,stroke-width:2px;
    classDef decision fill:#f4f4c3,stroke:#333,stroke-width:2px;
    classDef process fill:#cccccc,stroke:#000000,stroke-width:2px;
    class Z,B startEnd;
    class C decision;
    class A,D,E,F,G,Y,H process;
```

---

#### Implementation of Resource Methods

Depending on actual needs, users can selectively implement methods like `Initialize`, `Suspend`, `Recover`, and `Release`. For resources that do not require suspension or recovery, these methods can be omitted; the framework will automatically handle other lifecycle operations.