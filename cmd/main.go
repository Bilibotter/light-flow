package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"os/exec"
	"runtime"
	"strings"
)

type coverageInfo struct {
	line          string
	numStatements string
	coveredCount  int
}

// Generated by GPT, I'm not good at the command line.
func main() {
	// 获取当前工作目录
	pwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("Failed to get current working directory: %v", err)
	}
	// Step 1: Run tests in the 'test' directory
	testDir := "test"
	testCmd := fmt.Sprintf("go test -coverprofile=../cmd/coverage_test.out -coverpkg=../flow ./...")
	if err := runCommand(testDir, testCmd); err != nil {
		log.Fatalf("Failed to run tests in %s: %v", testDir, err)
	}

	// Step 2: Run tests in the 'flow' directory
	flowDir := "flow"
	flowCmd := "go test -coverprofile=../cmd/coverage_flow.out -coverpkg=../flow ./..."
	if err := runCommand(flowDir, flowCmd); err != nil {
		log.Fatalf("Failed to run tests in %s: %v", flowDir, err)
	}

	log.Println("Tests completed successfully.")
	coverageFiles := []string{"../cmd/coverage_test.out", "../cmd/coverage_flow.out"}
	outputFile := "coverage_combined.out"

	coverageMap := make(map[string]*coverageInfo)
	var order []string

	for _, file := range coverageFiles {
		err := processCoverageFile(file, coverageMap, &order)
		if err != nil {
			fmt.Printf("Error processing file %s: %v\n", file, err)
			return
		}
	}

	err = writeCombinedCoverage(outputFile, coverageMap, order)
	if err != nil {
		fmt.Printf("Error writing combined coverage: %v\n", err)
	}

	flowCmd = fmt.Sprintf("go tool cover -html=%s/coverage_combined.out", pwd)
	if err = runCommand(flowDir, flowCmd); err != nil {
		log.Fatalf("Failed to run tests in %s: %v", flowDir, err)
	}
}

func runCommand(dir, command string) error {
	var cmd *exec.Cmd
	if runtime.GOOS == "windows" {
		cmd = exec.Command("cmd", "/C", command)
	} else {
		cmd = exec.Command("sh", "-c", command)
	}

	// Redirect output to null device
	nullDev := os.DevNull
	stdout, err := os.OpenFile(nullDev, os.O_WRONLY, 0666)
	if err != nil {
		return err
	}

	cmd.Dir = fmt.Sprintf(`../%s`, dir)
	cmd.Stdout = stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func combineCoverage(files []string, outputFile string) error {
	coverageMap := make(map[string]*coverageInfo)
	var order []string

	for _, file := range files {
		if err := processCoverageFile(file, coverageMap, &order); err != nil {
			return fmt.Errorf("error processing file %s: %w", file, err)
		}
	}

	return writeCombinedCoverage(outputFile, coverageMap, order)
}

func processCoverageFile(filename string, coverageMap map[string]*coverageInfo, order *[]string) error {
	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()

		if strings.HasPrefix(line, "mode:") {
			continue
		}

		parts := strings.Fields(line)
		if len(parts) != 3 {
			continue
		}

		lineID, numStatements, count := parts[0], parts[1], parts[2]

		if _, exists := coverageMap[lineID]; !exists {
			*order = append(*order, lineID)
			coverageMap[lineID] = &coverageInfo{
				line:          lineID,
				numStatements: numStatements,
				coveredCount:  0, // 初始设置未覆盖
			}
		}

		if count != "0" {
			coverageMap[lineID].coveredCount++ // 每次文件中的代码覆盖了该部分，计数增加
		}
	}

	return scanner.Err()
}

func writeCombinedCoverage(filename string, coverageMap map[string]*coverageInfo, order []string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	if _, err := writer.WriteString("mode: set\n"); err != nil {
		return err
	}

	for _, lineID := range order {
		info := coverageMap[lineID]

		// 如果 coverageCount > 0，说明该部分在某些文件中已覆盖
		count := "0"
		if info.coveredCount > 0 {
			count = "1"
		}

		if _, err := writer.WriteString(fmt.Sprintf("%s %s %s\n", info.line, info.numStatements, count)); err != nil {
			return err
		}
	}

	return writer.Flush()
}
